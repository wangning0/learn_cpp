## 变量和基本类型
* `endl`称为操作符的特殊值，写入`endl`的效果是结束当前行，并将与设备有关联的缓冲区中的内容刷到设备中。
* `::`作用域运算符
* 当我们使用一个`istream`对象作为条件时，其效果是检测流的状态，当遇到**文件描述符**或遇到一个无效输入时，`istream`对象的状态才会变成无效。
* `short`短整型 16位
* `int`整型 16位
* `long`长整型 32位
* `long long`长整型 64位
* `float` 单精度浮点数 6位有效数字
* `double` 双精度浮点数 10位有效数字
* `long double` 扩展精度浮点数 10位有效数字
* 当我们赋给无符号类型一个超出它表示范围的值时，结果是初始值对无符号类型表示数值总数取模后的余数。
* 当我们赋给带符号类型一个超出它表示范围的值时，结果是**未定义的**，此时程序可能继续工作、可能崩溃、也啃呢个生成垃圾数据
* 编译器在每个字符串的结尾处添加一个空白符`\0`,因此，字符串字面值的实际长度要比它的内容多1
* `对象`是指一块能存储数据并具有某种类型的内存空间
* `C++`语言将声明和定义区分开来。`声明`使得名字为程序所知，一个文件如果想使用别处定义的名字则必须包含对那个名字的声明。`定义`负责创建与名字关联的实体。## 变量和基本类型
* `endl`称为操作符的特殊值，写入`endl`的效果是结束当前行，并将与设备有关联的缓冲区中的内容刷到设备中。
* `::`作用域运算符
* 当我们使用一个`istream`对象作为条件时，其效果是检测流的状态，当遇到**文件描述符**或遇到一个无效输入时，`istream`对象的状态才会变成无效。
* `short`短整型 16位
* `int`整型 16位
* `long`长整型 32位
* `long long`长整型 64位
* `float` 单精度浮点数 6位有效数字
* `double` 双精度浮点数 10位有效数字
* `long double` 扩展精度浮点数 10位有效数字
* 当我们赋给无符号类型一个超出它表示范围的值时，结果是初始值对无符号类型表示数值总数取模后的余数。
* 当我们赋给带符号类型一个超出它表示范围的值时，结果是**未定义的**，此时程序可能继续工作、可能崩溃、也啃呢个生成垃圾数据
* 编译器在每个字符串的结尾处添加一个空白符`\0`,因此，字符串字面值的实际长度要比它的内容多1
* `对象`是指一块能存储数据并具有某种类型的内存空间
* `C++`语言将声明和定义区分开来。`声明`使得名字为程序所知，一个文件如果想使用别处定义的名字则必须包含对那个名字的声明。`定义`负责创建与名字关联的实体。
* 如果想声明一个变量而非定义它，就在变量名前添加关键字`extern`，而且不要显示地初始化变量`extern int i;`
* 任何包含了显示初始化的声明即成为定义`extern double pi = 3.13;`定义
* `c++`标识符必须由字母、数字、下划线组成，必须以字母或下划线开头
* `引用`必须初始化，否则会报错
* 定义引用时，程序把引用和它的初始值绑定在一起，而不是将初始值拷贝给引用。
* **引用即别名**
* 指针无须在定义时赋初值。在块作用域内定义的指针如果没有被初始化，也将拥有一个不确定的值。
* `建议：`初始化所有指针，如果实在不清楚指针应该指向何处，就把它初始化为nullptr或0，这样程序就能检测并知道它没有任何具体的对象了
* `vodi*`是一种特殊的指针类型，可以用于存放任意对象的地址。
* 一切对象都存在引用
* 指向指针的引用 `int *&r = p;//r是一个对指针p的引用`
* 要想存放常量对象的地址，只能使用常量的指针。
* `*const`表示常量指针
* **常量指针**`int *const p1 = &i2`不改变p1的值
* **指向常量的指针**`const int *p2 = &ci`允许改变p2的值，但是*p2的值不变
* 定义类型别名`typedof`,`typedof double wages`wages是double的同义词
* `#define`指令把一个名字设定为预处理变量
* `#ifdef`当且仅当变量已定义时为真
* `ifndef`当且仅当变量未定义时为真，一旦检查结果为真，则执行后续操作直至遇到`#endif`指令为止
## 字符串、向量和数组
* `拷贝初始化`使用等号初始化一个变量
* `直接初始化`不使用等号
* `string`中的`getline(is,s)`表示从is中读取一行赋给s，返回is
* `string`对象会自动忽略开头的空白，并从第一个真正的字符开始读起，直到遇见下一处空白为止
* `string.empty()`若为空则返回`true`，非空返回`false`
* `string`类型的相加，必须确保每个加法运算符的两侧的运算对象至少又一个是`string`
* `cctype`头文件 主要用于处理单独的字符
* `for`语句处理单独字符

        for( declaration: expression )
            statement
        //eg
        string str("some thing");
        for( auto c: str ){
            //..            
        }
* `string::size_type`类型，也就是无符号类型
* `vector`对象之间的拷贝，一定要类型相同
* 要想列表初始化`vector`对象，花括号里的值必须与元素类型相同

        // v1有一个元素，其值为10
        vector<int> v1{10};
        // v2有10个默认初始化的值
        vector<string> v2{10};
        // v3有10个值为"hi"的值
        vect(or<string> v3{10,"hi"};
* `push_back()`给`vector`对象尾部增加元素
* 如果循环体内部包含有向`vector`对象添加元素的语句，则不能使用范围`for`循环(范围`for`循环内不应该改变其所遍历序列的大小)
* 所有标准库容器和字符类型都可以使用迭代器
* `begin`成员负责返回指向第一个元素的迭代器
* `end`成员负责返回指向最后一个元素的迭代器
* 标准容器迭代器的运算符

    * `*iter`返回迭代器iter所指元素的引用
    * `iter->mem`解引用iter并获取该元素的名为mem的成员函数等价于`(*iter).mem`
    * `++iter`/`--iter`令`iter`指示容器中的下一个元素/上一个元素
    
* 不能将数组的内容拷贝给其他数组作为其初始值，也不能用数组为其他数组赋值
* 默认情况下，类型修饰符从右向左依次绑定
        
        //从右向左，首先定义的是一个大到位10的数组，名字是ptrs，然后知道数组中存放的是指向int的指针
        int *ptrs[10];
        //parray指向一个含有10个整数的数组,从内到外观察
        int (*parray)[10] = &arr;
        //arrRef引用一个含有10个整数的数组
        int (&arrRef)[10] = arr;
* 在使用数组下标的时候，通常将其定义为`size_t`类型，`size_t`是一种机器相关的无符号类型，它被设计的足够大以便能表示内存中任意对象的大小，头文件为`stddef.h`
* 标准库函数`begin`和`end`，`begin`函数返回指向数组首元素的指针，`end`函数返回指向数组尾元素下一位置的指针，头文件为`iterator`

        int ia[] = {0,1,2,3,4};
        int *beg = begin(ia); //指向ia首元素的指针
        int *last = end(ia); //end函数指向ia尾元素下一位置的指针
* 两个指针相减的结果的类型是一种名为`ptrdiff_t`的标准库类型，和`size_t`一样
* `char *const cp`和`const char *p`,前者是cp不变，指向字符的指针常数，const指针，后者是定义一个指向字符常数的指针，cp可变，字符不可变。
* m%(-n)等价于m%n,(-m)%n等于-(m%n)
* 如果想声明一个变量而非定义它，就在变量名前添加关键字`extern`，而且不要显示地初始化变量`extern int i;`
* 任何包含了显示初始化的声明即成为定义`extern double pi = 3.13;`定义
* `c++`标识符必须由字母、数字、下划线组成，必须以字母或下划线开头
* `引用`必须初始化，否则会报错
* 定义引用时，程序把引用和它的初始值绑定在一起，而不是将初始值拷贝给引用。
* **引用即别名**
* 指针无须在定义时赋初值。在块作用域内定义的指针如果没有被初始化，也将拥有一个不确定的值。
* `建议：`初始化所有指针，如果实在不清楚指针应该指向何处，就把它初始化为nullptr或0，这样程序就能检测并知道它没有任何具体的对象了